---
title: "The Grammar of Graphics and using ggplot2"
output: 
  html_notebook:
    code_folding: show
---

Prepared by [Brandon Seah](mailto:kb.seah@tuebingen.mpg.de), June 2019, for the "R for Bioscientists" course at MPI Developmental Biology.

# Learning objectives

By the end of this module, students should be able to ... 

Conceptual:

 * Define the components of a graphical plot, and be able to identify them in a given plot: data, aesthetic mapping, geometric object, statistical transformation, scaling, coordinate system, and facetting. 
 * Describe commonly used aesthetic mappings: position, size, color.
 * Be aware of perceptual limitations or possibly misleading results that can arise with certain aesthetic mappings, especially size and color.
 * Explain the advantages of showing individual data points, in addition to summary statistics, and methods to avoid overplotting.

Practical:

 * Build a plot with `ggplot2` using `geom_`, `scale_` and `facet_` elements
 * Apply data wrangling and tidy data skills learned from previous sessions to prepare data for `ggplot2`
 * Use ggplot2 inline documentation and find help online

# Prelude: Graphics in base R

Graphics functions in base R: `plot`, `points`, `hist`, `par`, `legend`, `text`, `abline`, to name the most common ones.

**Further reading** - [R Base Graphics: An Idiot's Guide](https://rpubs.com/SusanEJohnston/7953)

We'll play with the `iris` dataset that is bundled with R.


```{r}
data(iris)
```

Before we can plot anything, we should see how the data object is structured:


```{r}
str(iris) # structure of the object
```

Within this data frame there are four numerical variables, and one factorial one `Species`. 

Let's say we want to see how `Sepal.Length` and `Petal.Width` are correlated with each other, for each of the three different species:


```{r}
plot(x=iris$Petal.Width,y=iris$Sepal.Length,col=iris$Species)
```

Which color corresponds to which species? Use `legend` to overlay a legend to the plot


```{r}
plot(x=iris$Petal.Width,y=iris$Sepal.Length,col=iris$Species)
legend(x="bottomright", # where to position the legend
       col=c(1,2,3), # which colors to use 
       legend=levels(iris$Species), # legend text
       pch=1 # which plot character to use
       )
```

Instead of color, one could also key the points by their shape ("plot character", hence `pch`), say for those journals that make you pay extra for color:


```{r}
plot(x=iris$Petal.Width,y=iris$Sepal.Length,pch=as.numeric(iris$Species))
legend(x="bottomright", # where to position the legend
       pch=c(1,2,3), # which plot character to use 
       legend=levels(iris$Species) # legend text
       )
```

Why `pch=as.numeric(...)`? That's because takes `pch` takes a numeric argument, whereas `iris$Species` has a factorial data class, and has to be coerced into the correct class to deliver the desired results. Why does it work with `col`, then? Actually you can try `col=as.numeric(iris$Species)` and that will work too, so I dunno.

A lot of manual control over plot parameters is possible, however, base R graphics requires some familiarity with some of the squishy innards of R, and you have to take care of some fairy basic things yourself:

 * The legend is positioned within the plot area, if you want to put it outside the plot frame you need to specify dimensions and margins
 * Plot character has to be manually specified in the legend
 * Colors have to be manually specified - here it is implied that we are using the currently-active palette 
 * Legend text has to be manually specified - as the plots get more complex, you have to make sure that `plot()` is reading off the levels of the factor in the same order as `levels()`... 

Now what if I want to facet the plot? I.e. to have three plots of Sepal.Length vs. Petal.Width, each for a single species, and side by side? 


```{r}
par(mfrow=c(1,3)) # Set up plot device with three "slots"
for (sp in levels(iris$Species)) { # For each value of Species
  tmp <- subset(iris, Species==sp) # Subset the iris dataset
  plot(tmp$Sepal.Length, tmp$Petal.Width, main=sp)
}
```

Phew! But notice a few things:

 * The scales of each plot are all different. That's because each plot is independent. One could just as well have three completely unrelated plots side by side. 
 * We used a loop to iterate across the values of Species, and we need to know ahead of time how many panels we want, to tell the `par()` function ahead of time.
 * If we want to generate an array of plots ('facetting'), then we would need to figure out how to do it manually each time. 

**The upshot: Plotting in base R lets you control lots of tiny details, but you spend a lot of time on low-level things.**

**`ggplot2` lets you focus on high-level data visualization, saving you time, mental effort, and typing.**

Let's see how to do the equivalent with `ggplot2` now.

# Starting ggplot2

First let's load the library:


```{r}
library(ggplot2) # Load ggplot2 by itself
library(tidyverse) # Or along with the whole tidyverse
```

# Simple scatterplot with factors as colors


```{r}
iris.plot <- ggplot(iris) + geom_point(aes(x=Petal.Width, y=Sepal.Length, col=Species)) # Plots can be assigned to objects
iris.plot # display the plot
```

Notice how the legend is automatically generated, and is outside the plot frame. 

## Scatterplot with element size scaled to a variable


```{r}
ggplot(iris) + geom_point(aes(x=Petal.Width, y=Sepal.Length, col=Species, size=Sepal.Width))
```

Notice how the size parameter automatically re-scales to the max and min of the data. As such it tends to exaggerate the differences in your data. To scale the size quantitatively, such that a value of 0 corresponds to a point of zero area, use `scale_size_area()`:


```{r}
ggplot(iris) + geom_point(aes(x=Petal.Width, y=Sepal.Length, col=Species, size=Sepal.Width)) + scale_size_area()
```

By default the size scaling is by area, not by width. This is because humans perceive size differences in terms of area, so a width or radius-based scaling would be misleading, as the area varies with the square of the radius.

## Scatterplot with facetting 


```{r}
iris.plot + facet_wrap(~Species) # We just add one more element to the previous object
```

## Scatterplot with logarithmic scale

It's also easy to change from a linear scale to e.g. a logarithmic scale.


```{r}
iris.plot + scale_x_log10()
```

# Elements of a plot

Each data plot, like the ones shown above, can be broken down into the following elements:

 * **Data** - the underlying information that is being graphically represented
 * **Aesthetic mapping** - the visual metaphor being used to represent the data
 * **Geometric object** - the actual geometric form being used, e.g. points, lines, polygons, bars, heatmaps... 
 * **Statistical transformation** - whether the individual data are plotted, or if they are first transformed or summarized by some statistical function such as the mean, standard deviation, etc.
 * **Scaling** - transformation applied to the data when translating them into the aesthetic, e.g. linear or log scale for position, color scale
 * **Coordinate system** - usually Cartesian, but could be polar, etc.
 * **Facetting** - instead of a single plot, splitting the data up by some factor and generating an array of plots, one for each subset

Data visualization is a kind of visual language, and like natural languages it has a grammar of rules and conventions that people generally follow, although they are usually learned subconsciously and exercised in an intuitive way. The elements listed above are the building blocks of the "grammar of graphics", that was first systematically laid out in a book by Leland Wilkinson. `ggplot2` is built on these principles (hence the `gg` in its name), although it doesn't follow Wilkinson's scheme exactly. 

Notice how the functions and parameters in `ggplot2` have names that tell you which part of the grammar they belong to:

 * **Data** - The data to be plotted is usually the first argument specified to the `ggplot()` function
 * **Aesthetic mapping** - `aes` parameter 
 * **Geometric object** - e.g. `geom_point()`, `geom_line()`, `geom_histogram()`
 * **Statistical transformation** - `stat_identity()`, `stat_summary()`
 * **Scaling** - `scale_x_log10()`, `scale_x_sqrt()`, `scale_color_continuous()`
 * **Coordinates** - `coord_cartesian()`, `coord_flip()`, `coord_polar()`
 * **Facetting** - `facet_wrap()`, `facet_grid()`

**Exercise** 

 * Explain a histogram in terms of the graphical elements listed above.

# Steps in building a plot

 1. Know what you want to plot
 2. Start with `ggplot()` to specify data object 
 3. Add a `geom_` layer and specify appropriate `aes` aesthetic. Repeat as necessary to overlay
 4. Change `stat_`, `scale_` and `coord_` if the defaults are not what you want
 5. Apply `facet_` by a given factor if necessary

# Exercises

1. Data wrangling and plotting 

Import the data file `divorce_margarine.tsv` and view its contents. How would you wrangle the table to plot trend of divorce_rate_maine vs year and margarine_consumption_per_year vs year as facets or as two overlaid lines? Is this a useful way to present the data, in this case?


```{r}
divmarg <- read.delim("../Data/divorce_margarine.tsv")
divmarg.new <- divmarg %>% gather(key="var",value="value",divorce_rate_maine,margarine_consumption_per_capita)
ggplot(divmarg.new) + geom_point(aes(x=year,y=value)) + facet_wrap(~var,nrow=2) + scale_y_log10()
```


2. Drawing lines 

Use the `gapminder.tsv` data. Plot the change in life expectancy vs. year with `geom_line`, one line per country, and color or facet by the continent. Hint: `group` aesthetic. Can you superimpose a summary trend line for each continent? 

Food for thought: in Rwanda in 1994, the life expectancy was 13.2. What does that tell us about how mortality is distributed in the population?


```{r}
gapminder <- read.delim("../Data/gapminder.tsv")
ggplot(gapminder,aes(x=year,y=life_expectancy)) + geom_line(aes(group=country,col=continent),alpha=0.2) + facet_wrap(~continent,nrow=1)
```



# Some useful principles in data visualization

## Show your data

If you have few data points, it is a good idea to show the individual points, and not just summary statistics (e.g. mean and standard deviation). 

## Dealing with overplotting or dense data

If you have too many data points, plotting the individual points can obscure the actual distribution pattern, as points overlap with each other. Depending on the kind of plot, there are a number of ways to deal with this. The iris dataset is quite sparse, so we'll use the `diamonds` dataset which is much denser.


```{r}
data(diamonds)
str(diamonds)
```


### Jittering 

Useful only with one-dimensional data. Instead of plotting them in a straight line, you can "jitter" them in either the x or y axis so they don't overlap:

Without jittering:


```{r}
ggplot(diamonds) + geom_point(aes(x=cut,y=price)) 
```

With jittering:


```{r}
(ggplot(diamonds) 
 + geom_jitter(aes(x=cut,y=price), 
               height=0,  # Don't jitter in the vertical axis (i.e. Sepal.Length)
               width=0.2 # Jitter only 0.2 width in the horizontal axis
               )
 + scale_y_log10() # better spread of the data
 )
```

Slightly better.

### Summary statistics


If the data are one-dimensional a simple histogram will do:


```{r}
ggplot(diamonds) + geom_histogram(aes(price)) + scale_x_log10()
```


If you want to show several distributions side by side, arrayed by factor, you could `facet_wrap` an array of histograms by that factor, or use boxplots. Boxplots are a more informative way to summarize the spread of the data, and can be overlaid with the individual data points if you want:


```{r}
(ggplot(diamonds) 
 + geom_boxplot(aes(x=cut,y=price))
 + scale_y_log10()
 )
```

Boxplots represent a five-number summary of the data: median (middle line), 25th and 75th percentiles (the box, or "hinges"), and 1.5 times the interquartile range from the "hinges" ("whiskers").

An alternative to boxplots are violinplots, which are more like inkblots. The advantage to violinplots over boxplots is when the data are not unimodal (single-peaked), for the boxplot implicitly assumes unimodality.


```{r}
(ggplot(diamonds) 
 + geom_violin(aes(x=cut,y=price))
 + scale_y_log10()
)
```


### Transparency 

By making points slightly transparent, you can see where they are overlapping, up to a point.

### Heatmaps

Instead of plotting the individual points, use a color scale to represent their density. 

This involves a statistical transformation, binning, which is just like a histogram, except in two dimensions instead of only one.


```{r}
(ggplot(diamonds, aes(x=depth, y=price)) 
 + geom_bin2d()
 + scale_y_log10() # Make the spread of values easier to see
)
```


One can also use hexagonal bins:


```{r}
library(hexbin) # Requires this package to be installed, if you don't have it already
(ggplot(diamonds, aes(x=depth, y=price)) 
 + geom_hex()
 + scale_y_log10() # Make the spread of values easier to see
 )
```


### Contour plots

Like on topographical maps. You should be able to figure this one out by now!

Hint: It's not `geom_contour`


```{r}
(ggplot(diamonds, aes(x=depth, y=price)) 
 + geom_density_2d(aes(color=stat(level))) # color by levels of density
 + scale_y_log10() # Make the spread of values easier to see
 )
```


## Using colors responsibly

### Avoid rainbow scales for quantitative data 

What people perceive is not just color but also apparent brightness. Colors on a rainbow scale, although "evenly spaced", are not equally bright to the eye:


```{r}
palette(rainbow(6, # presented by Tom Clancy
                start=0)) 
barplot(rep(1,times=6),col=1:6, axes=FALSE)
```


The blue is noticeably darker than the cyan next to it. Yellow appears somewhat brighter than the adjacent red and green.

Using a rainbow scale will mislead people into seeing discontinuities in the data where there are not.


```{r}
(ggplot(diamonds, aes(x=depth, y=price)) 
 + geom_density_2d() 
 + stat_density_2d(geom="raster", aes(fill=stat(density)), contour=FALSE)
 + scale_fill_gradientn(colors=rainbow(6,start=0)) # Destroy your retinas
 + scale_y_log10() # Make the spread of values easier to see
 )
```

If we are asked to pick a cutoff value, we would naturally be drawn to the bright yellow line or the dark blue lines.

Consider the example of where to define the gates in flow cytometry, for example.

Fortunately the defaults in ggplot2 have been sensibly chosen. The default color scale is not so painful:


```{r}
(ggplot(diamonds, aes(x=depth, y=price)) 
 + geom_density_2d() 
 + stat_density_2d(geom="raster", aes(fill=stat(density)), contour=FALSE)
 + scale_y_log10() # Make the spread of values easier to see
 )
```

### Color-blind-safe colors

A number of the Color Brewer palettes are color-blind-safe (see [ColorBrewer2 homepage](http://colorbrewer2.org/#)).

The Viridis color scales are also designed with color-blindness in mind.

**Further reading**

 * ["Color palettes matter"](http://mkweb.bcgsc.ca/brewer/talks/color-palettes-brewer.pdf) by Martin Krzywinski

# Some special kinds of plots

Histograms

Boxplots and violin plots

## "Bars-and-stars" plot

I don't mean [this](https://en.wikipedia.org/wiki/United_States_Army_officer_rank_insignia), but [this](http://felixfan.github.io/bar-plot/).

Let's break down what goes into this graph:

 * Bar - some kind of central tendency, usually the mean
 * Error bars - some measure of spread, or a confidence interval 
 * Stars representing results of some kind of significance test

For descriptive statistics and data exploration, bars and stars plots are not really useful because they obscure the actual data underlying the plot. See ["Kick the bar chart habit"](https://www.nature.com/articles/nmeth.2837) from the Points of Significance blog for a fuller explanation on why bar charts are not recommended for most purposes.

Using the `iris` dataset again:


```{r}
(ggplot(iris,aes(x=Species,y=Sepal.Width))
  + geom_boxplot(outlier.shape = NA) # Don't plot outliers, because the raw data will be overlaid
  + geom_jitter(width=0.2,height=0) # Jitter in the horizontal but not vertical axis
)
```


> "But I really really want a bar plot!"

The boxplot has some advantages compared to the plain bars, because it ... 

> "NOW!"

Okay fine.


```{r}
(ggplot(iris,aes(x=Species,y=Sepal.Width)) 
  + stat_summary_bin(geom="bar",fun.y="mean") # Fill up space with little information
  + stat_summary_bin(geom="errorbar") # Add error bars
)
```

But wait, these error bars are suspiciously narrow! And there was a warning message, too. 

The default summary function used to calculate the error bars is `mean_se()`, which gives mean +/- standard error of the mean (SE). But beware! The SE looks nice and narrow, but it is not necessarily what you really want. 

For the standard deviation, you'll need to specify the summary function `mean_sdl` explicitly. `mean_sdl` by default gives error bars of 2 standard deviations. For 1 standard deviation, you'll need to supply it as an [anonymous (or "lambda") function](https://en.wikipedia.org/wiki/Anonymous_function):


```{r}
(ggplot(iris,aes(x=Species,y=Sepal.Width)) 
  + stat_summary_bin(geom="bar",fun.y="mean") # Fill up space with little information
  + stat_summary_bin(geom="errorbar",fun.data= function(x) {mean_sdl(x,mult=1)}) # Add error bars
)
```

Why is it so hard to do in ggplot2?

 * Make you think about what your error bars actually represent
 * For EDA and/or summary statistics, boxplots + points overlay is a better choice


# Common pitfalls

## Pitfall 1. Data is not structured properly

Let's go back to the `iris` dataset. There are four numerical variables being measured: the height and width of petals, and height and width of sepals. 


```{r}
head(iris) # take a peek
```


How can I color the plot by flower-part, i.e. "sepal" and "petal"? Let's try `ggplot(iris) + geom_point(col=... wait a moment` 

"Sepal" and "Petal" are part of the variable names, but these variables could be named "boo", "coo", "doo" and "foo" for that matter. To color, you need the flower part name to be a factor variable. 


```{r}
iris.named <- data.frame(iris, specimen=1:dim(iris)[1]) # Add a new column numbering each specimen from 1 to N

# Use gather from tidyr package (part of tidyverse) to gather up the numerical variables
iris.long <- iris.named %>% gather(key="measurement", value="value", Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)

head(iris.long)
```

Split the column "measurement" by the "." character - aren't you glad the variables were not named foo, doo, etc?


```{r}
iris.long.split <- iris.long %>% separate(col="measurement",into=c("part","parameter"),sep="[.]")

head(iris.long.split)
```


```{r}
# Now spread it out again by "parameter"
iris.new <- iris.long.split %>% spread(key="parameter", value="value")

head(iris.new)
```

Okay now we can plot


```{r}
ggplot(iris.new) + geom_point(aes(Length,Width,col=part))
```

**Exercises** 

 1. Explain why we had to add the column `specimen` above. 
 2. Explain why `gather()`ing by the column `Species` wouldn't make sense.

**Further reading** ["Tidy data"](http://vita.had.co.nz/papers/tidy-data.pdf) by Hadley Wickham

## Pitfall 2. Mixing up `fill` and `col` aesthetics

## Pitfall 3. Continuous vs. qualitative color scales

## Pitfall 4. Zero values in log-scaled plots

## Pitfall 5. Cannot break ggplot command across multiple lines

Sometimes you want to break a ggplot command across several lines for the sake of legibility. However the following code will not work:

```
ggplot2(mtcars, aes(x=cyl,y=mpg))
+ geom_point()
```

That's because the whole thing is a single statement, but R will not know that, and will try to interpret each line as a separate command, throwing an error on the second line.

Instead you should enclose the whole command in parentheses, so that R will wait for the closing parenthesis before running the command:

```{r}
(ggplot2(mtcars, aes(x=cyl,y=mpg))
 + geom_point()
)
```


# Readings and resources

On ggplot2 in particular:

 * [ggplot2 cheatsheet](https://github.com/rstudio/cheatsheets/blob/master/data-visualization-2.1.pdf)
 * Hadley Wickham (2010) [A Layered Grammar of Graphics](http://vita.had.co.nz/papers/layered-grammar.pdf) - original paper describing how the grammar of graphics was implemented in `ggplot2` and the reasoning behind the package's design.
 * Garrett Grolemund & Hadley Wickham (2017) [R for Data Science](https://r4ds.had.co.nz/) - Chapter 3 ["Data Visualization"](https://r4ds.had.co.nz/data-visualisation.html) is mostly about `ggplot2`

On data visualization generally:

 * Howard Wainer (1984) [How to display data badly](https://www.jstor.org/stable/2683253)
 * Edward Tufte. The Visual Display of Quantitative Information (ISBN 978-1930824133)
 * Howard Wainer (1997) Visual Revelations (ISBN 9780387949024)
 * Leland Wilkinson. The Grammar of Graphics